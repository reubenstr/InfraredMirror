// Matrix effect by Jeremy Williams
// Designed for Game Frame
// http://www.ledseq.com

#include <FastLED.h>

// LED setup
#define kMatrixWidth  24
#define kMatrixHeight 32
#define DATA_PIN 8
#define NUM_LEDS 768
uint8_t ledBrightness = 192;

CRGB leds[NUM_LEDS];

void setup()
{
  // LED Init
  FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS).setDither(0);
  FastLED.setBrightness(ledBrightness);
  FastLED.show();
}

void loop()
{
  EVERY_N_MILLIS(75) // falling speed
  {
    const CRGB spawnColor = CRGB(125,255,125 );
    
    // move code downward
    // start with lowest row to allow proper overlapping on each column
    for (int8_t row=kMatrixHeight-1; row>=0; row--)
    {
      for (int8_t col=0; col<kMatrixWidth; col++)
      {
        if (leds[getIndex(col, row)] == spawnColor)
        {
          leds[getIndex(col, row)] = CRGB(27,130,39); // create trail
          if (row < kMatrixHeight-1) leds[getIndex(col, row+1)] = spawnColor;
        }
      }
    }

    // fade all leds
    for(int i = 0; i < NUM_LEDS; i++) 
    {
      if (leds[i].g != spawnColor.g) leds[i].nscale8(192); // only fade trail
    }

    // spawn new falling code
    if (random8(3) == 0) // lower number == more frequent spawns
    {
      int8_t spawnX = random8(kMatrixWidth);
      leds[getIndex(spawnX, 0)] = spawnColor;
    }

    FastLED.show();
  }
}

// convert x/y cordinates to LED index on zig-zag grid
uint16_t getIndex(uint16_t x, uint16_t y)
{

uint16_t i = x + y * 24;

    uint16_t xMatrix = (i % 24) / 8;
    uint16_t yMatrix = i / (64 * 3);    
    uint16_t matrixIndex = 11 - (xMatrix + 3 * yMatrix);

    // inside matrix x, y
    uint16_t xL = 7 - ((i % 24) % 8);
    uint16_t yL = 7 - (i / 24) % 8;
    uint16_t pixel = 64 * matrixIndex + (xL + (8 * yL)); 

return pixel;

  /*
  uint16_t index;
  if (y == 0)
  {
    index = x;
  }
  else if (y % 2 == 0)
  {
    index = y * kMatrixWidth + x;
  }
  else
  {
    index = ((y * kMatrixWidth) + (kMatrixWidth-1)) - x;
  }
  return index;
  */
}
